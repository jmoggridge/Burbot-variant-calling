---
title: 'Project 3: Variant calling in Burbot (*Lota lota*) using `freebayes` and `mpileup`'
author: "J Moggridge"
date: "06/03/2021"
output: 
  pdf_document:
    highlight: kate
bibliography: references.bib
link-citations: true
---

```{r setup, echo=F}
knitr::opts_chunk$set(warning = F, message = F)
```

------------------------------------------------------------------------

# Introduction

<!-- purpose of variant calling -->

The analysis of genetic variants (single-nucleotide polymorphisms -SNPs and insertions/deletions - indels), by high-throughput sequencing has applications in studies of phylogeny and population structure, quantitative-trait loci, genome-wide associations, among others. Such polymorphic sites are also of practical interest in medical genomics, *eg*. to discover disease-causing mutations [@cornish2015], and in agriculture, where SNPs can be used as genetic markers to guide breeding of crops [@yao2020] and livestock [@ni2015]. As the cost of sequencing has decreased greatly and computational resources have improved, these techniques have become increasingly popular.

The identification of polymorphic sites from sequencing data, known as variant calling, is performed after alignment of reads to a reference genome. Because high-throughput sequencing and read-mapping are error-prone, it is challenging but essential to differentiate true variants from artefacts, particularly in low-coverage data [@nielsen2011]. Many tools for variant calling have been created for this classification task (`bcftools`, `GATK`, `freebayes`, *etc.*), though these differ in their statistical models for inferring genotypes. Further filtering of variants is generally applied after calling, and how this is performed will vary depending on the nature of the study.

In the current work I compared variant calling by two tools: `bcftools mpileup/call` (previously `samtools`) and `freebayes`. Both `bcftools` and `freebayes` apply Bayesian models to estimate genotype posterior probabilities, though they differ in how this is implemented. `bcftools` uses a two step process where `mpileup` first creates the 'pileup' of all reads at variant sites, and then `call` is used to infer genotypes at these [@li2011, @danecek2021]. This implementation has the advantage of being very fast. `freebayes` a uses different approach to inferring haplotypes in that it does not use the alignment but the full reads [@garrison2012, @howtof]. 

In this work, I used `bcftools` and `freebayes`callers to find biallelic SNPs. The results were compared in terms of the number of SNPs, the overlap between sets, the depth at each position, and their minor allele frequencies. Previous comparisons of variant callers have often found low concordance between tools and issues with sensitivity [@orawe2013, @cornish2015], though others have reported high concordance and accuracy in their results [@hwang2015]. Best method could depend on nature of the sequencing data: eg. whole-genome, RAD-seq, RNA-seq, scRNA-seq, etc, and the depth of coverage.

------------------------------------------------------------------------

# Methods

Data can be found on `cedar` in `/scratch/jmoggrid/Project3/`. <!-- (chmod 755 /scratch/username/directory/ -R). --> <!-- srun --pty --account="def-nricker" -t 0-03:00:00 --mem=32000 /bin/bash -->

### Dataset

I used data from project \#2 in this work, specifically the reads mapped to the burbot reference with the `bowtie2` aligner. I used `bcftools mpileup` and `GATK HaplotypeCaller` to call variants for the ten individuals using these alignments.

I first needed to convert my `.sam` files to `.bam` format and index them, as well as adding read groups using `picard` (necessary for `freebayes`).

```{r sam-to-bam and readgroups, engine = 'bash', eval = FALSE, echo=TRUE}
#!/bin/bash
# to convert .sam to .bam, then sort & index
module load samtools
for file in bam/*.sam; do
  name=`echo $file | sed 's/\.sam//'`
  samtools view -b -S -o $name.bam $file
  samtools sort $name.bam -o $name.sorted.bam;
  samtools index $name.sorted.bam
done

# add readgroups and re-index; show output to verify
module load picard 
group=1
for file in bam/*.sorted.bam
do
  label=`echo $file | sed 's/.sorted.bam//'`
  java -jar $EBROOTPICARD/picard.jar AddOrReplaceReadGroups I=$file \
    O=$label.rg.sorted.bam RGID=$group RGLB=lib1 RGPL=illumina RGPU=unit1 RGSM=$label
  samtools index $label.rg.sorted.bam
  echo "group number: $group; file: $file; read group:"
  samtools view -H $label.rg.sorted.bam | grep "@RG"
  group=$((group+1))
done
```

### `bcftools mpileup` and `freebayes` variant calling

I ran `bcftools` variant calling for the 10 .sorted.bam files. For `mpileup`, I added arguments to provide annotations for read depth and allelic depth (-a DP,AD) and to specify Illumina as the sequencing platform (-P). For `call`, I provided arguments to specify the use of the multi-allelic caller, 'variants only', to skip indels, and to provide the genotype quality scores (GQ).

```{r mpileup, engine = 'bash', eval = FALSE, echo=TRUE}
module load nixpkgs/16.09  gcc/7.3.0 bcftools/1.9
# mpileup and variant calling
bcftools mpileup -Ou -a DP,AD -P ILLUMINA \
-f ./burbot_ref/GCA_900302385.1_ASM90030238v1_genomic.fna ./bam/*.rg.sorted.bam | \
bcftools call -mv --format-fields GQ --skip-variants indels -o  mpileup.call.vcf
bcftools stats mpileup.call.vcf > mpileup.call.stats
```

I called SNPs using `freebayes` with default settings; annotations for genotype quality were requested with `--genotype-qualities`. Output was limited to SNPs by piping to `vcffilter`.

```{r freebayes, engine = 'bash', eval = FALSE, echo = TRUE}
module load freebayes/1.2.0
# create a list of 10 filenames to pass to as input to freebayes
> files.txt
for file in bam/*.rg.sorted.bam; do echo $file >> files.txt; done
# free-bayes calling for 10 files and restricting vcf output to SNPs w vcffilter
freebayes -f burbot_ref/GCA_900302385.1_ASM90030238v1_genomic.fna  \
  --genotype-qualities --bam-list files.txt | \
vcffilter -f "TYPE = snp" > freebayes.call.vcf
bcftools stats freebayes.call.vcf > freebayes.call.vcf
```

### Filtering variant calls

I used the `vcftools` library to filter variant calls. Biallelic SNPs (`--min-alleles 2 --max-alleles 2 --remove-indels`) were retained if they had a quality score of at least 20 (`--minQ 30`). Genotypes were retained at these sites if they had genotyping quality score of at least 10 (`--minGQ 10`). I found the vast majority of variants to be shared among all 10 individuals, so I applied filters for the maximum and minimum minor allele frequencies, such that these would not be either zero or one (`–maf 0.01 –max-maf 0.99`). Any calls that did not receive a 'PASS' flag were discarded (`--remove-filtered-all`).

```{r filtering, engine='bash', eval = FALSE, echo = TRUE}
module --force purge; module load StdEnv/2020 vcftools/0.1.16

# filter mpileup calls 
vcftools --vcf mpileup.call.vcf --minQ 20 --minGQ 10 \
  --min-alleles 2 --max-alleles 2 --maf 0.01 --max-maf 0.99 \
  --remove-filtered-all --recode --recode-INFO-all \
  --out mpileup.filter

# same thing for freebayes
vcftools --vcf freebayes.call.vcf --minQ 20 --minGQ 10 \
  --min-alleles 2 --max-alleles 2 --maf 0.01 --max-maf 0.99 \
  --remove-filtered-all --recode --recode-INFO-all \
  --out freebayes.filter
```

There was no need to exclude any individuals from the analysis, as none had more that 22.5% missing data in the filtered `mpileup` calls, while the proportions of missing data in `freebayes` calls was roughly half as large (from `--missing-indv`).

```{r check_missing, engine='bash', eval = FALSE, echo = TRUE}
# check individuals' missing data
vcftools --vcf mpileup.filter.recode.vcf --missing-indv \
  --out mpileup.filter
vcftools --vcf freebayes.filter.recode.vcf --missing-indv \
  --out freebayes.filter
```

### Summarizing SNP calls

I counted the biallelic SNP calls from each caller with `bcftools stats`.

```{r count_snps, engine = 'bash', eval = FALSE, echo = TRUE}
module load StdEnv/2020 bcftools/1.10.2
bcftools stats mpileup.filter.recode.vcf | grep "number of SNPs:" | cut -f4
bcftools stats freebayes.filter.recode.vcf | grep "number of SNPs:" | cut -f4
```

The overlap between sets of SNPs was computed with `bcftools isec`.

```{r overlap_in_sets, engine = 'bash', eval = FALSE, echo = TRUE}
# prepare files for isec by zipping and re-indexing
bgzip mpileup.filter.recode.vcf
bcftools index mpileup.filter.recode.vcf.gz
bgzip freebayes.filter.recode.vcf
bcftools index freebayes.filter.recode.vcf.gz
# Compute intersection of 2 files with isec
bcftools isec -p isec mpileup.filter.recode.vcf.gz freebayes.filter.recode.vcf.gz
```

<!-- # Get overlap data from isec into tsv format -->

<!-- > Overlap.vals -->

<!-- for file in isec/*.vcf -->

<!-- do  -->

<!--   bcftools stats $file| grep "number of SNPs:" | cut -f4 >> Overlap.vals -->

<!-- done -->

<!-- echo $'unique to mpileup\nunique to freebayes\nshared\nshared' > Overlap.names -->

<!-- paste  Overlap.names Overlap.vals > Overlap.tsv -->

<!-- sed -i '1s/^/SNPs\tCount\n/' Overlap.tsv -->

Using `vcftools`, I computed the following:

-   Allele frequency at each loci across individuals

```{r vcf_freq, engine = 'bash', eval = FALSE, echo = TRUE}
vcftools --gzvcf mpileup.filter.recode.vcf.gz --freq \
  --out mpileup.filter
vcftools --gzvcf freebayes.filter.recode.vcf.gz --freq --out freebayes.filter
```

-   Sum depth at each locus across individuals

```{r vcf_site_depth, engine = 'bash', eval = FALSE, echo = TRUE}
vcftools --gzvcf mpileup.filter.recode.vcf.gz --site-depth --out mpileup
vcftools --gzvcf freebayes.filter.recode.vcf.gz --site-depth --out freebayes
```

-   Mean depth for each individual across all loci

```{r vcf_indv_depth, engine = 'bash', eval = FALSE, echo = TRUE}
vcftools --gzvcf mpileup.filter.recode.vcf.gz --depth --out mpileup
vcftools --gzvcf freebayes.filter.recode.vcf.gz --depth --out freebayes
```

<!-- ## Relatedness -->

<!-- vcftools --gzvcf mpileup.filter.recode.vcf.gz --relatedness --out mpileup -->

<!-- vcftools --gzvcf freebayes.filter.recode.vcf.gz --relatedness --out freebayes -->

<!-- ## Convert to (0,1,2) format -->

<!-- vcftools --gzvcf mpileup.filter.recode.vcf.gz --012 --out mpileup -->

<!-- vcftools --gzvcf freebayes.filter.recode.vcf.gz --012 --out freebayes -->

<!-- quality, as shown in class, using what you think is a reasonable threshold. Compare the resulting vcf files in several ways. First, *compare the number of SNPs* and the *overlap of these SNPs across files*. -->

<!-- Then, plot the *minor allele frequency* and depth of all SNPs (summed across individuals), and discuss the variation across loci. Compare across vcfs produced by different variant callers. -->

```{=html}
<!-- # get data down from cedar in local terminal:
 scp jmoggrid@cedar.computecanada.ca:/scratch/jmoggrid/Project3/Overlap.tsv .
 scp jmoggrid@cedar.computecanada.ca:/scratch/jmoggrid/Project3/*.frq . 
 scp jmoggrid@cedar.computecanada.ca:/scratch/jmoggrid/Project3/*.idepth . 
 scp jmoggrid@cedar.computecanada.ca:/scratch/jmoggrid/Project3/*.ldepth .  -->
```

------------------------------------------------------------------------

### Statistics

I created figures and summary tables from the data generated above using the `R` language.

```{r load data, message=FALSE}
#! {R code}
library(tidyverse, quietly = T)

# Overlap counts table; add
Overlap <- read_delim('./data/Overlap.tsv', '\t') %>%  
  distinct() %>% 
  bind_rows(
    tibble(SNPs = c('mpileup', 'freebayes'), 
           Count = c(.[1,2][[1]] + .[3,2][[1]], 
                     .[2,2][[1]] + .[3,2][[1]]))) %>%  
  arrange(desc(Count))

# Allele frequencies
cnames <- c('chrom','pos', 'n_alleles','n_chr','a1','a2')
AlleleFreq <-  
  bind_rows(
    read_tsv('./data/freebayes.filter.frq', col_names = cnames, skip = 1L) %>% 
      mutate(caller = 'freebayes'),
    read_tsv('./data/mpileup.filter.frq', col_names = cnames, skip = 1L) %>% 
      mutate(caller = 'mpileup')
  ) %>% 
  mutate(allele = str_extract(a1, '[A-Z]+'), 
         frequency = str_remove_all(a1, '[A-Z]+:'),
         allele2 = str_extract(a2, '[A-Z]+'), 
         frequency2 = str_remove_all(a2, '[A-Z]+:')
  ) %>% 
  mutate(across(contains('freq'), as.numeric)) %>%
  mutate(
    maf = ifelse(frequency > 0.5, 1 - frequency, frequency),
    minor_allele = ifelse(maf == frequency, allele, allele2)
  )

# Depth
cnames <- c('individual', 'n sites', 'mean_depth')
IndvDepth <- bind_rows(
    read_tsv('./data/mpileup.idepth', col_names = cnames, skip = 1L) %>%
      mutate(caller = 'mpileup'),
    read_tsv('./data/freebayes.idepth', col_names = cnames, skip = 1L) %>%
      mutate(caller = 'freebayes')
  ) %>% 
  mutate(individual = str_remove_all(individual, 'bam.|.bowtie.burbot'),
         caller = as_factor(caller)) %>% 
  arrange(individual)

# Site Depth
cnames <- c("chr", "pos", "allele_depth", "var_depth")
SiteDepth <- bind_rows(
  read_tsv('./data/mpileup.ldepth', col_names = cnames, skip = 1L) %>%
    mutate(caller = 'mpileup'),
  read_tsv('./data/freebayes.ldepth', col_names = cnames, skip = 1L) %>%
    mutate(caller = 'freebayes')
) %>% mutate(caller = as_factor(caller))

vcf_df <- SiteDepth %>%
  rename(chrom = chr) %>% 
  left_join(AlleleFreq, by = c('chrom', 'pos', 'caller'))
# glimpse(vcf_df)

cnames <- c('id', 'quality', 'n_snps', 'ts', 'tv', 'indels')
qual_df <- 
  read_tsv("./data/freebayes.quality.stats",
                 skip = 1L, col_names = cnames) %>% 
  mutate(caller = "freebayes") %>% 
  bind_rows(
    read_tsv("./data/mpileup.quality.stats",
                 skip = 1L, col_names = cnames) %>% 
  mutate(caller = "mpileup")
  ) 

```

```{r figs, echo=F}
library(ggbeeswarm)
library(patchwork)
library(rcartocolor)
library(gridExtra)
library(grid)
# Allele frequency histogram (alleles stacked)
fig_allelefreq <- 
  ggplot(AlleleFreq) +
  geom_histogram(aes(x = maf), bins = 20, alpha = 0.8) +
  facet_wrap(caller~., scales = 'free_y') +
  labs(x = 'minor allele frequency', y='loci') +
  theme_bw()

# The distribution of depth per-site summed across individuals
fig_sitedepth <- 
  ggplot(SiteDepth, aes(x = allele_depth, fill = caller, color = caller)) +
  geom_density(alpha = 0.12) +
  geom_vline(aes(xintercept = mean(allele_depth), color = caller),
             lty = 2) +
  scale_x_log10() +
  labs(x = 'depth per locus', y = 'density') +
  guides(colour = guide_legend(override.aes = list(size=1, pch=15))) +
  theme_bw() +
  theme(legend.position = c(.8,.7))

# The distribution of mean depth per site within individuals
set.seed(45)
fig_indvdepth <-
  ggplot(IndvDepth, aes(y = mean_depth, x = caller)) +
  geom_violin(alpha = 0.1, draw_quantiles = c(.25, .5, .75), trim = F) +
  geom_quasirandom(aes(color = individual), size = 3, width = 0.3) +
  scale_color_carto_d(palette = 2) +
  guides(colour = guide_legend(override.aes = list(size = 4, pch = 16))) +
  facet_wrap( ~ caller, scales = 'free_x') +
  labs(y = 'mean depth per locus', x = '', color = 'Individual') +
  theme_bw() +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    legend.position = 'right'
  )

# Allele depth over maf, coloured by n chromosomes
fig_alleledepth_over_maf <- 
  ggplot(vcf_df, aes(x=maf, y=allele_depth, color = n_chr)) +
  geom_point(size = 0.5, alpha = 0.7) +
  scale_y_log10() +
  facet_wrap(~caller) +
  scale_color_viridis_c() +
  labs(x = "Minor allele frequency",
       y = "Allele depth", 
       color="Number of\nchromosomes") +
  theme_bw()
```

------------------------------------------------------------------------

\newpage

# Results

From the ten burbots in our sample, `mpileup` called a total of 132,046 SNPs, 173 of which were multiallelic, and with a transition:transversion ratio (ts:tv) of 0.81; `freebayes`called a total of 106,973 SNPs, with 1761 being multiallelic, and ts:tv of 0.44 (table 1). After applying filters for these were reduced to 11,115 SNPs with a 0.87 transition:transversion ratio for `mpileup` calls and 6,722 SNPs with 1.09 transition:transversion ratio for `freebayes` calls. The sets of biallelic SNPs identified by each caller were compared (table 2): `mpileup` called `r round(Overlap[1,2][[1]] * 100 / Overlap[2,2][[1]], 2) - 100` % more biallelic SNPs than `freebayes`. Of these, a large proportion (`r scales::comma(Overlap[3,2][[1]])`) were shared between both sets, representing `r round(Overlap[3,2][[1]] * 100 /Overlap[1,2][[1]], 2)` % of `mpileup` calls and `r round(Overlap[3,2][[1]] * 100 /Overlap[2,2][[1]], 2)` % of `freebayes` calls. Additionally, `r Overlap[4,2][[1]]` SNPs were unique to `mpileup` and `r Overlap[5,2][[1]]` to `freebayes`.

The distribution minor allele frequencies of SNPs from `mpileup` shows a U-shape with peaks at 0.05 and 0.5, whereas those from `freebayes` peak at 0.05 and are otherwise evenly distributed (fig.1A). The sum depth per locus across all individuals is generally in the range of 50-200 reads, with both callers showing similar distributions (fig.1B). The mean depth for `mpileup` was 173.7 reads and for `freebayes` 162.2 reads. Both callers have some extreme outliers in terms of site depth: the maximum depth for `freebayes` was 16,162 reads, while for `mpileup` it was only 2522 reads. The minimum site depth was 5 and 3 for `freebayes` and `mpileup` respectively and `mpileup` has a greater proportion of low-depth sites.

------------------------------------------------------------------------

```{r table1_filtering, echo=FALSE}
tribble(
  ~ Caller, ~ `raw SNPs`, ~ `raw ts/tv`, ~ `post-filter SNPs`, ~ `post-filter ts/tv`,
  "mpileup", 132046, 0.81, 11115, 0.87,
  "freebayes", 106973, 0.44, 6722, 1.09
) %>% pander::pander(caption = "Raw and filtered SNP counts and transition/transversion ratios for calls by mpileup and freebayes.")
```

```{r table2_overlap, echo=F}
Overlap %>% pander::pander(caption = "Total, shared, and unique SNPs called by mpileup and freebayes (after filtering).")
```

```{r fig1, echo=F, fig.align = 'center', fig.width=7, fig.height=3, fig.cap="(A) Distribution of minor allele frequency; SNPs with frequency = 0 or 1 were omitted. (B) Distribution of depth per locus summed across all individuals (note log-scaled x-axis)."}

(fig_allelefreq + fig_sitedepth) &
plot_layout(guides = 'keep') &
plot_annotation(tag_levels = 'A')
```

```{=html}
<!-- Zeggini, E., & Morris, A. (2015). Assessing Rare Variation in Complex Traits Design and Analysis of Genetic Studies (1st ed. 2015.). Springer 
New York. <https://doi.org/10.1007/978-1-4939-2824-8> -->
```
```{r engine = 'bash', eval=FALSE}
## quality scores...
grep -E "Quality" mpileup.filter.recode.stats | cut -f1 --complement > mpileup.quality.stats
grep ^QUAL mpileup.filter.recode.stats | cut -f1 --complement >> mpileup.quality.stats 
grep -E "Quality" freebayes.filter.recode.stats | cut -f1 --complement > freebayes.quality.stats
grep ^QUAL freebayes.filter.recode.stats | cut -f1 --complement >> freebayes.quality.stats 
```


```{r echo = F}
fig_quality_dist <- qual_df %>% 
  mutate(QUAL = round(quality/25)*25) %>% 
  group_by(QUAL, caller) %>% 
  summarise(n_snps = sum(n_snps),
            ts  = sum(ts),
            tv = sum(tv)) %>% 
  pivot_longer(cols = c(ts,tv)) %>% 
  ggplot(aes(x = QUAL, y = value, fill = name)) +
  geom_col(width = 19) +
  facet_wrap(~caller) +
  scale_fill_carto_d(palette = 2) +
  labs(x="quality score", y = "loci", fill = NULL) +
  scale_y_log10() +
  theme_bw()

```

\newpage

# Discussion

<!-- Sites with low quality were discarded -->

<!-- Kept all allele freq, even rare ones ... rare ones are cool because reference... depends of system of interest though ... -->

<!-- Sites with extremely large depth could represent paralogous regions? -->

Comparison of callers: Hwang2015; Cornish2015

-   Reflect on results

-   Concurrence with other findings

    -   If not, why not (data...)

-   Characteristics of the data affect variant calls?

    -   Reference was highly fragmented, though \~85 % reads mapped to the reference in all individuals (in earlier work)

    -   

-   Other features of the VCF that are notable ? The mean read depth across all sites is larger for all individuals in the `freebayes` SNPs (fig. 2). Perhaps this is because freebayes is less tolerant of low-coverage sites in it's estimation of genotype likelihood/ quality / ....

-   What other filters:

    -   Depth.... high coverage can indicate a paralogous region (duplicated)

    -   Might be interested in triallelic snps or indels, depending on the study...

    -   If looking for rare variants we would perhaps want to not use filters and only look at positions that are relevant to the process or disease of interest [@cornish2015].

Both `freebayes` and `mpileup` apply Bayes' theorem in their algorithms for SNP calling.

mpileup considers the bases at a variant position

freebayes uses a window approach that differs from other bayesian callers which treat the alignment similarly...

cornish

-   callers have high positive predictive value (TP/TP+FP) but low sensitivity (TP/P).

-   Freebayes identified more raw SNPs (far more false positive) in the human exome data; but mpileup and freebayes had similar counts after filtering.

-   Freebayes did not perform as well as mpileup.

------------------------------------------------------------------------

# Supplemental Figures

```{r}
fig_alleledepth_over_maf
```

```{r fig2, echo=F, fig.align = 'center', fig.width=5, fig.height=2.9, fig.cap="Mean depth per locus for each individual."}
fig_indvdepth
```

```{r fig3, echo=F, fig.align = 'center', fig.width=5, fig.height=2.9, fig.cap="Mean depth per locus for each individual."}
fig_alleledepth_over_maf
```

```{r}

```

\newpage

# References
